# This code has been generated by Google Gemini
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog, messagebox
import time
import os
import FeatureExtractor #Logic for extracting features

# --- Configuration ---
# NOTE: Set the absolute path to your desired root directory here.
DEFAULT_ROOT_DIRECTORY = r'D:\Senior Project 2 CSCI-457\Datasets\amd_data'
UPDATE_INTERVAL_MS = 50 # GUI update rate (Simulated processing time per file)

# --- State Variables ---
start_time = 0
# State trackers for the two bars
total_dirs = 0
total_files_in_workflow = 0
current_dir_count = 0 
current_file_count = 0
current_dir_max_files = 0
# NEW: Total files processed across all directories
total_files_processed = 0 
# NEW: List to track individual file processing times (for ETC calculation)
file_process_times = []
# NEW: Timestamp of the last successful file process completion
last_update_time = 0

# UI References
task_title_label = None
folder_progress_label = None
subtask_progress_label = None 
timer_label = None
# NEW: Estimated Time Remaining Label
etc_label = None
root_window = None
folder_bar = None
subtask_bar = None
cwd_label = None 
total_files_label = None 

# Workflow data
workflow_iterator = None
current_dir_path = ""
current_file_list = []
ROOT_DIRECTORY_PATH = ""


# --- Core Logic Functions ---

def prepare_workflow(root_path):
    """
    Pre-scans the directory to calculate totals and prepares the iterator.
    Returns: (Total Directories, Total Files, Walk Iterator)
    """
    global total_dirs, total_files_in_workflow
    
    dir_count = 0
    file_count = 0
    
    # Store the actual os.walk data to iterate over later
    workflow_data = [] 

    # Perform a quick scan to get all counts
    for dirpath, dirnames, filenames in os.walk(root_path):
        dir_count += len(dirnames) # Count subdirectories
        # Only count files that are *not* directories themselves in the current view
        valid_filenames = [f for f in filenames if f.lower().endswith('.apk')]
        file_count += len(valid_filenames)
        if valid_filenames or not dirnames: # Add the entry if it contains files or is an empty directory
            workflow_data.append((dirpath, valid_filenames))

    # The total number of steps in the first bar is the number of directories visited.
    total_dirs = len(workflow_data) 
    total_files_in_workflow = file_count
    
    if total_dirs == 0:
        # Check if root path has files but no subdirs, still treat as one step
        if not total_files_in_workflow:
            # Handle case where directory is empty
            print(f"Directory {root_path} is empty. Task completed.")
            return 0, 0, iter([])
        
    # Return an iterator over the prepared data
    return total_dirs, total_files_in_workflow, iter(workflow_data)

def calculate_etc():
    """Calculates and updates the Estimated Time Remaining (ETC)."""
    global etc_label

    # Avoid calculation if no files have been processed yet
    if not total_files_processed:
        etc_label.config(text="Approximate Time Remaining: Calculating...")
        return
        
    # 1. Calculate Average Time Per File
    # In this simulated environment, we use the sum of simulated times.
    # In a real environment, this would be the actual time measured for each file.
    total_time_spent_processing = sum(file_process_times)
    average_time_per_file = total_time_spent_processing / total_files_processed
    
    # 2. Calculate Time Remaining
    files_remaining = total_files_in_workflow - total_files_processed
    time_remaining_seconds = files_remaining * average_time_per_file
    
    # 3. Format Output
    
    # Convert remaining time to H:M:S format
    etc_minutes = int(time_remaining_seconds // 60)
    etc_seconds = int(time_remaining_seconds % 60)
    
    etc_label.config(text=f"Approximate Time Remaining: {etc_minutes:02d}m {etc_seconds:02d}s")


def update_gui():
    """Recursively drives the processing task and updates the progress bars."""
    global current_dir_count, current_file_count, current_dir_max_files, total_files_processed
    global current_dir_path, current_file_list, workflow_iterator, last_update_time

    # 1. Timer Update (always runs, now includes total files processed)
    elapsed_time = time.time() - start_time
    minutes = int(elapsed_time // 60)
    seconds = int(elapsed_time % 60)
    
    # Update Timer and Total Files Processed Label
    timer_label.config(text=f"Time: {minutes:02d}:{seconds:02d} | Files Processed: {total_files_processed}/{total_files_in_workflow}")
    
    # Check if we are done with all directories
    if current_dir_count < total_dirs:
        
        # --- Sub-Task (File Bar) Iteration ---
        if current_file_count < current_dir_max_files:
            
            # Calculate time taken for the last file *before* simulating the next step
            time_taken_for_file = 0
            if last_update_time:
                time_taken_for_file = time.time() - last_update_time
                file_process_times.append(time_taken_for_file)
            
            # --- START REAL WORK: APK FEATURE EXTRACTION ---
            
            current_apk_filename = current_file_list[current_file_count]
            current_apk_path = os.path.join(current_dir_path, current_apk_filename)
            
            # Call the external function to extract features and write to file
            extracted_features = FeatureExtractor.extract_features_and_write(
                apk_path=current_apk_path,
                base_output_path=os.path.dirname(os.path.abspath(__file__))
            )
            
            # Update unique features tracking
            if extracted_features:
                FeatureExtractor.update_unique_features(
                    features=extracted_features, 
                    base_output_path=os.path.dirname(os.path.abspath(__file__))
                )

            # --- END REAL WORK ---
            
            # Update tracking counts
            current_file_count += 1
            total_files_processed += 1 # Increment total count
            
            # Update timestamp for next calculation
            last_update_time = time.time()

            # Update MOVED Sub-Task Label (Now below the second bar)
            file_name = current_file_list[current_file_count - 1] if current_file_list else "Processing folder..."
            subtask_progress_label.config(
                text=f"Current Task: {file_name} ({current_file_count}/{current_dir_max_files} files)"
            )
            subtask_bar['value'] = current_file_count
            
            # Recalculate and update the overall folder bar value
            completed_dirs_value = current_dir_count + (current_file_count / current_dir_max_files if current_dir_max_files else 0)
            folder_bar['value'] = completed_dirs_value
            
            # Recalculate and display ETC
            calculate_etc()
            
            # Schedule the next file step (simulated work time)
            root_window.after(1, update_gui)
            
        else:
            # --- Folder Iteration: Sub-Task Completed, move to Next Directory ---
            try:
                # Get the next directory from the prepared iterator
                dirpath, filenames = next(workflow_iterator)
                
                # Update global state for the next folder
                current_dir_path = dirpath
                current_file_list = filenames
                current_dir_max_files = len(filenames)
                current_dir_count += 1 # Increment overall directory count
                current_file_count = 0 # Reset file counter for the new directory

                # Set bar maximums
                subtask_bar['maximum'] = current_dir_max_files if current_dir_max_files else 1
                
                # UPDATE NEW CWD LABEL to show only the folder name
                folder_name = os.path.basename(current_dir_path)
                # Handle the case where the path is the root directory itself (basename might be empty)
                if not folder_name:
                    folder_name = os.path.basename(ROOT_DIRECTORY_PATH)
                    
                cwd_label.config(text=f"Current Folder: {folder_name}")

                # Update Folder Progress Label (First Bar)
                folder_progress_label.config(
                    text=f"Progress in <{os.path.basename(ROOT_DIRECTORY_PATH)}>: {current_dir_count}/{total_dirs} directories"
                )
                
                # Recalculate and display ETC immediately before next step
                calculate_etc()
                
                # Recursively call update_gui immediately to process the first file in the new directory
                root_window.after(1, update_gui) 
                
            except StopIteration:
                # Iterator is exhausted (should be caught by the outer if, but safe fallback)
                root_window.after(1, update_gui)
    
    else:
        # --- Task Completed ---
        
        # Calculate final elapsed time stat
        final_elapsed_time = time.time() - start_time
        final_minutes = int(final_elapsed_time // 60)
        final_seconds = int(final_elapsed_time % 60)
        
        # COMBINED STAT: Time Elapsed and Total Files Processed
        final_stat_str = (
            f"Time Elapsed: {final_minutes:02d}m {final_seconds:02d}s (DONE) | "
            f"Total Files Processed: {total_files_in_workflow}"
        )
        
        folder_progress_label.config(text=f"Progress in <{os.path.basename(ROOT_DIRECTORY_PATH)}>: {total_dirs}/{total_dirs} directories")
        subtask_progress_label.config(text="All tasks complete: 100% (Ready to close)")
        timer_label.config(text=final_stat_str) # Use the new combined string
        etc_label.config(text="Approximate Time Remaining: 00m 00s")
        
        # Ensure bars are full
        folder_bar['value'] = total_dirs
        subtask_bar['value'] = current_dir_max_files
        
        print("Workflow completed!")

def start_extraction_workflow():
    """Handles the button click, prepares data, and switches the UI."""
    global ROOT_DIRECTORY_PATH, workflow_iterator, start_time, total_dirs, total_files_in_workflow, last_update_time
    
    # Use the predefined constant
    ROOT_DIRECTORY_PATH = DEFAULT_ROOT_DIRECTORY
    
    if not os.path.isdir(ROOT_DIRECTORY_PATH):
        messagebox.showerror("Error", f"Invalid directory: {ROOT_DIRECTORY_PATH}. Please check the DEFAULT_ROOT_DIRECTORY constant.")
        # Quit application if the directory is invalid
        root_window.destroy()
        return

    try:
        # 1. Pre-scan the directory
        total_dirs, total_files_in_workflow, workflow_iterator = prepare_workflow(ROOT_DIRECTORY_PATH)
        
        # If no files or directories are found (handled in prepare_workflow)
        if total_dirs == 0 and total_files_in_workflow == 0:
            setup_completion_ui()
            return
            
        # 2. Build and show the progress UI
        setup_progress_ui()
        
        # 3. Initialize time and start the recursive loop
        start_time = time.time()
        last_update_time = time.time() # Initialize last update time
        root_window.after(100, update_gui)
        
    except FileNotFoundError as e:
        messagebox.showerror("Error", str(e))
        root_window.destroy()

def setup_progress_ui():
    """Builds the labels and bars for the progress display."""
    global task_title_label, folder_progress_label, subtask_progress_label, timer_label, folder_bar, subtask_bar, cwd_label, etc_label
    
    # Set window size for progress view (Increased height to 280 for the new label)
    root_window.geometry("450x280") 
    
    # --- Title Label ---
    task_title_label = ttk.Label(root_window, text="Extracting Features from APK Files", font=('Helvetica', 14, 'bold'))
    task_title_label.pack(pady=(15, 5))

    # --- 1. Folder Progress Bar (First Bar) ---
    root_folder_name = os.path.basename(ROOT_DIRECTORY_PATH)
    folder_progress_label = ttk.Label(root_window, text=f"Progress in <{root_folder_name}>: 0/{total_dirs} directories", font=('Helvetica', 10))
    folder_progress_label.pack(pady=(10, 2))
    
    folder_bar = ttk.Progressbar(root_window, orient="horizontal", length=400, mode="determinate")
    folder_bar.pack(pady=5)
    folder_bar['maximum'] = total_dirs
    folder_bar['value'] = 0

    # --- NEW: Current Folder Label ---
    cwd_label = ttk.Label(root_window, text="Current Folder: Starting...", font=('Helvetica', 10))
    cwd_label.pack(pady=(5, 2)) 
    
    # --- 2. Sub-Task Progress Bar (Second Bar) ---
    subtask_bar = ttk.Progressbar(root_window, orient="horizontal", length=400, mode="determinate")
    subtask_bar.pack(pady=5)
    subtask_bar['maximum'] = 1 
    subtask_bar['value'] = 0

    # --- MOVED: Current Task Label (Now below the second bar) ---
    subtask_progress_label = ttk.Label(root_window, text="Current Task: Waiting for initialization...", font=('Helvetica', 10, 'italic'))
    subtask_progress_label.pack(pady=(5, 2))
    
    # --- Timer/Files Label (Combined for efficiency and space) ---
    timer_label = ttk.Label(root_window, text="Time: 00:00:00 | Files Processed: 0/0", font=('Helvetica', 10, 'italic'))
    timer_label.pack(pady=10)

    # --- NEW: Estimated Time Remaining Label ---
    etc_label = ttk.Label(root_window, text="Approximate Time Remaining: Calculating...", font=('Helvetica', 10, 'bold'))
    etc_label.pack(pady=5)


def setup_completion_ui():
    """Simple UI for when the task is skipped (e.g., empty directory)."""
    root_window.geometry("450x100")
    ttk.Label(root_window, text="Task Skipped: Directory is Empty.", font=('Helvetica', 14, 'bold')).pack(pady=20)
    
def create_progress_bar_popup():
    """Initializes the window and automatically starts the workflow."""
    global root_window

    root_window = tk.Tk()
    root_window.title("Feature Extraction Workflow")
    # Initial small size, will resize in setup_progress_ui
    root_window.geometry("450x50") 
    
    # Center the window on the screen
    screen_width = root_window.winfo_screenwidth()
    screen_height = root_window.winfo_screenheight()
    x = (screen_width / 2) - (450 / 2)
    y = (screen_height / 2) - (50 / 2)
    root_window.geometry(f"+{int(x)}+{int(y)}")

    # Automatically start the workflow after the window is fully initialized
    root_window.after(10, start_extraction_workflow)

    root_window.mainloop()

if __name__ == "__main__":
    create_progress_bar_popup()
